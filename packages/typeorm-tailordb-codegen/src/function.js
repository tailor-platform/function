export default async (args) => {
    const client = new tailordb.Client({ namespace: args.namespace });
    const columns = (await client.queryObject(
    // Use the same metadata surface as Kysely path for stability
    "SELECT * FROM kysely_column_metadata;")).rows;
    const grouped = groupByTable(columns);
    const code = renderEntities(grouped);
    return { data: code };
};
function groupByTable(cols) {
    const map = new Map();
    for (const c of cols) {
        const key = `${c.schema}.${c.table}`;
        const t = map.get(key) ?? { schema: c.schema, name: c.table, isView: c.table_type === 'v', columns: [] };
        t.columns.push(c);
        map.set(key, t);
    }
    return [...map.values()].sort((a, b) => (a.schema === b.schema ? a.name.localeCompare(b.name) : a.schema.localeCompare(b.schema)));
}
function pascalCase(name) {
    return name
        .replace(/[_\s-]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''))
        .replace(/^(\d)/, '_$1')
        .replace(/[^A-Za-z0-9_]/g, '');
}
function tsTypeFromPg(type) {
    const t = type.toLowerCase();
    if (/(int|serial|smallint|bigint|decimal|numeric|double|real)/.test(t))
        return 'number';
    if (/(bool|boolean)/.test(t))
        return 'boolean';
    if (/(json|jsonb)/.test(t))
        return 'any';
    if (/(date|time|timestamp)/.test(t))
        return 'Date';
    if (/(uuid)/.test(t))
        return 'string';
    if (/(char|text|varchar|citext)/.test(t))
        return 'string';
    if (/(bytea)/.test(t))
        return 'Buffer';
    return 'any';
}
function typeormColumnTypeFromPg(type) {
    // Pass-through Postgres type names normally work for TypeORM Postgres driver
    return type;
}
function renderEntities(tables) {
    const lines = [];
    lines.push("/* eslint-disable */");
    lines.push("// Generated by @tailor-platform/function-typeorm-tailordb-codegen");
    lines.push("import { Entity, Column, PrimaryColumn, PrimaryGeneratedColumn } from 'typeorm';");
    lines.push("");
    for (const t of tables) {
        const className = pascalCase(`${t.schema}_${t.name}`);
        lines.push(`@Entity({ name: '${t.name}', schema: '${t.schema}' })`);
        lines.push(`export class ${className} {`);
        for (const c of t.columns) {
            const isId = c.column === 'id';
            const isAuto = !!c.auto_incrementing;
            const colType = typeormColumnTypeFromPg(c.type);
            const tsType = tsTypeFromPg(c.type);
            const nullable = !c.not_null;
            const comment = c.column_description?.replace(/\n/g, ' ');
            if (isId && isAuto) {
                lines.push(`  @PrimaryGeneratedColumn({ type: '${colType}' })`);
            }
            else if (isId) {
                lines.push(`  @PrimaryColumn({ type: '${colType}'${nullable ? ', nullable: true' : ''} })`);
            }
            else {
                lines.push(`  @Column({ type: '${colType}'${nullable ? ', nullable: true' : ''} })`);
            }
            if (comment) {
                lines.push(`  /** ${comment} */`);
            }
            lines.push(`  ${c.column}: ${tsType};`);
            lines.push("");
        }
        lines.push("}");
        lines.push("");
    }
    return lines.join("\n");
}

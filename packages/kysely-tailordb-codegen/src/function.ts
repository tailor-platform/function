import type { TableMetadata } from "kysely";
import {
  EnumCollection,
  PostgresDialect,
  TypeScriptSerializer,
} from "kysely-codegen";

export default async (args: { namespace: string }) => {
  const client = new tailordb.Client({
    namespace: args.namespace,
  });
  const columns = (
    await client.queryObject<RawColumnMetadata>(
      // To avoid unstable dependencies on SQL generated by Kysely, issue a SELECT statement to the special metadata table `kysely_column_metadata`.
      // Tailor Platform must return results corresponding to `RawColumnMetadata` for this SQL.
      "SELECT * FROM kysely_column_metadata;",
    )
  ).rows;
  const tables = parseTableMetadata(columns);
  const dialect = new PostgresDialect();
  const metadata = dialect.introspector.createDatabaseMetadata({
    tables,
    domains: [],
    partitions: [],
    enums: new EnumCollection(),
  });
  const data = new TypeScriptSerializer().serializeFile(metadata, dialect);
  return { data };
};

// Since Kysely's parseTableMetadata is not exported, it is copied below.
// https://github.com/kysely-org/kysely/blob/0.28.2/src/dialect/postgres/postgres-introspector.ts#L103
const parseTableMetadata = (columns: RawColumnMetadata[]): TableMetadata[] => {
  return columns.reduce<TableMetadata[]>((tables, it) => {
    let table = tables.find(
      (tbl) => tbl.name === it.table && tbl.schema === it.schema,
    );

    if (!table) {
      table = Object.freeze({
        name: it.table,
        isView: it.table_type === "v",
        schema: it.schema,
        columns: [],
      });

      tables.push(table);
    }

    table.columns.push(
      Object.freeze({
        name: it.column,
        dataType: it.type,
        dataTypeSchema: it.type_schema,
        isNullable: !it.not_null,
        isAutoIncrementing: !!it.auto_incrementing,
        hasDefaultValue: it.has_default,
        comment: it.column_description ?? undefined,
      }),
    );

    return tables;
  }, []);
};

interface RawColumnMetadata {
  column: string;
  table: string;
  table_type: string;
  schema: string;
  not_null: boolean;
  has_default: boolean;
  type: string;
  type_schema: string;
  auto_incrementing: boolean | null;
  column_description: string | null;
}
